// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;

// Prioritize ANON_KEY explicitly, and ensure we never use a non-JWT key
const rawAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
const rawPubKey = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Helper to validate JWT format (starts with eyJ)
const isValidJWT = (key: string | undefined): boolean => !!key && key.startsWith('eyJ');

// Select the best available key
const SUPABASE_PUBLISHABLE_KEY = isValidJWT(rawAnonKey) ? rawAnonKey : (isValidJWT(rawPubKey) ? rawPubKey : '');

// Validation
if (!SUPABASE_PUBLISHABLE_KEY) {
  console.error(
    "CRITICAL ERROR: No valid Supabase JWT found!", 
    "VITE_SUPABASE_ANON_KEY:", rawAnonKey ? (isValidJWT(rawAnonKey) ? 'Valid JWT' : 'Invalid Format') : 'Missing',
    "VITE_SUPABASE_PUBLISHABLE_KEY:", rawPubKey ? (isValidJWT(rawPubKey) ? 'Valid JWT' : 'Invalid Format') : 'Missing'
  );
}

// FORCE LOG THE KEY FOR DEBUGGING
console.log('--- SUPABASE CLIENT DEBUG ---');
console.log('VITE_SUPABASE_URL:', SUPABASE_URL);
console.log('USING KEY:', SUPABASE_PUBLISHABLE_KEY ? (SUPABASE_PUBLISHABLE_KEY.slice(0, 10) + '... (Valid JWT)') : 'FAILED TO RESOLVE KEY');
console.log('--- END DEBUG ---');

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// NOTE: Fingerprinting logic removed to prevent aggressive token deletion during dev/prod switching
// This ensures that valid tokens are not cleared just because env vars might jitter.

const wrappedFetch: typeof fetch = async (input, init) => {
  try {
    return await fetch(input, init);
  } catch (e) {
    const err = e as { name?: unknown; message?: unknown };
    const name = typeof err?.name === 'string' ? err.name : '';
    const message = typeof err?.message === 'string' ? err.message : '';
    const signalAborted =
      !!init &&
      typeof init === "object" &&
      "signal" in init &&
      (init as { signal?: AbortSignal | null }).signal?.aborted === true;
    const isAbort =
      name === 'AbortError' ||
      message.toLowerCase().includes('aborted') ||
      message.includes('ERR_ABORTED') ||
      signalAborted;

    if (isAbort) {
      return new Response(JSON.stringify({ message: 'Request aborted', code: 'ABORTED' }), {
        status: 499,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    throw e;
  }
};

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  },
  global: {
    fetch: wrappedFetch
  }
});
